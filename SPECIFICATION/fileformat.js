/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

  ######  #  #       ######      ######   ####   #####   #    #    ##    #####
  #       #  #       #           #       #    #  #    #  ##  ##   #  #     #
  #####   #  #       #####       #####   #    #  #    #  # ## #  #    #    #
  #       #  #       #           #       #    #  #####   #    #  ######    #
  #       #  #       #           #       #    #  #   #   #    #  #    #    #
  #       #  ######  ######      #        ####   #    #  #    #  #    #    #

  _TABLE_OF_CONTENT _FILE_FORMAT
  :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ### ROADMAP:

// FORMAT - docpad.coffee or settings.js or package.json
// ######
// [settings.js] // if possible: package.json
// module.exports = {
//   // ...
//   holon: {
//     // FILL IN STUFF HERE
//     widgets: [
//       // needs to include all folder and/or file names used in src/documents
//       // and map them to names, which are present in:
//       // src/widgets/[names]
//       // or missing ones need to be present in "package.json" under "dependencies"
//       // e.g.
//       "pages": "widget1",       // see src/widgets/widget1
//       "posts": "superpost",     // see dependencies, is in node_modules
//       "pages/home": "superpost" // overwrites more generic definitions
//       // this array is extended and entries can even be replaced,
//       // there should be NO FIELD given in "pages/home/index.md" itself,
//       // because duck typing should make suggestions for the package.json field
//       // based on properties and widget descriptions
//       // "field" specified in "home document" itself says something new
//       // or "field" specified here overwrites
//     ]
//   },
//   dependencies: {
//     "superpost": "0.2.4"
//   }
//   // ...
// };
//
//
//
//
// FORMAT - content.md
// ######
// "The more structured a content, the more data in the
// <attributes> area of a document -> there is need for widgets for
// every possible type of content. a generic type which just shows <CONTENT>
// and specialized widgets which only use fields and no generic <CONTENT> at all,
// thus becomes e.g. pure yaml or json..."
// --- # metadata
// title: titleToReferenceThisMetaDataInTheFuture
// date: ..
// ---
// <CONTENT>
//
//
//
// COMMANDS
// ########:
// docpad run                a.k.a blacksmith /path/to/project
//
// e.g. content.md or similar
// 1. input src/[document] // this thing: pre-selected set of data ready for presentation through "WIDGET"
// // goal1: classify "real world experience"
//             ==> refactor dependencies
// // goal2: over time, refactor content into fields
//             THINK:
//             Content should be unique in each document.
//             if content in documents is repetitive, its a strong hint,
//             that a new "widget" would be handy to factor out repetition.
// // goal3: create more specific WIDGETS for document representation
// //    think about asking for 'default widget' and 'duck typing widget' to feed this document into
//         -> infer widget from attributes
//         vs.
//         -> infer widget from type label attribute (check and throw if not compatible)
//           => type label is optional, but during compile time, all options should be listed,
//           => with option to label a document as one or more "types"
//           LABELs will be used to:
//           -----------------------
//           1. typecheck for widget and warn about missing fields
//           2. generate missing fields when possible
//           3. look up more needed details from other sources
//             (-> a label can be a link to more detailed spec)
//             => thus: other CONTENT! (e.g. authorName->authorProfile)
// module.exports =  { // preselection fed into widget[s]
//   // front matter
//   meta        : { // generated by engine based on settings
//     revisions   : [timestamps], // ordered list of key(timestamp)-value(documentversion)-pairs
//     // implicitely generated, thus exported + usable in CONTENT
//     assets      : {paths/to/local/files}, // assets used in content or any fields are discovered during runtime
//     dependencies: contains everything that was required // is generated at runtime
//       e.g. {/documents/authors/author1.json}.lastName
//     //
//   },
//   attributes    : { // but instead of "attributes: { ... }" its attrib1: "..", attrib2, ".." etc...
//     // fields = axiom values | requires() | computed(axiom values, requires(), blob)
//     e.g.
//     - means of data creation
//     - time/date of creation
//     - purpose of data
//     - creator of data
//     - location on computer network during creation
//     - used standards
//     - whatever...
//   },
//   // CONTENT
//   // content is multi line HTML + reactive data binding is "plates template",
//   // which is only synced back if backend is available via "websockets" and creates
//   // new revisions of items
//   // requires() should use "dependencies.xyz" instead
//   // thus, CONTENT can "insert" ATTRIBUTES on the fly in order to e.g. create a blog post flow
//   // which uses content from ATTRIBUTES, which come potentially from other files
//   // think "inline referenced content into markdown" + "github marked parser"
//   // check BLACKSMITH how they do it.
//   content     : "
//     // blob = sample data with goal to be refactored over time into 'oblivion' if possible
//     // SAMPLE, once completely explainable by other things, (=becomes pure metadata)
//     //   can substituted by 'creation' through 'requires'
//     // STRUCTURE of CONTENT + CONTENT BLOB FIELD is
//     //   SAMPLE DATA (can be a lot or little)
//   "
// }
// => {
//   'path/to/my-file.md': {
//     title: 'A Catchy Title',
//     draft: true,
//     contents: new Buffer('An unfinished article...')
//   }
// }
//
//
// 2. pipe through <widgets>
// 3. output out/
//     + contains the rendered project
//     + updates revisions for changed nodes
//     + generates log file with details and stats over about what content has been rendered
//     + ...
//
// ////////////////// ALTERNATIVE HOLON CONTENT ITEM FILE STRUCTURE
// see "holon/WORKBENCH/holonContentFile.js"


/////////////////////////
// HEXO FORMAT to compare
// [EXAMPLE_CONTENT.md]
//   title: Hello World
//   date: 2013/7/13 20:46:25
//   categories:
//   - Diary
//   tags:
//   - PS3
//   - Games
//   ---                       # "---" divides "front-matter" from "content"
//   foobar content of file
//   // its possible t use: http://hexo.io/docs/tag-plugins.html
//
// FRONT MATTER:
// #############
// Write the front-matter in YAML format. Don’t use tabs in the front-matter, use spaces instead. Also, add a space after colons.
// All settings regarding a "content item" can be made in the "front matter"
// Setting	      Description	                            Default
//   layout	     Layout	                                 post/page
//   title	       Title
//   date	       Published date	                         File created date
//   updated	     Last updated date	                     File last updated date
//   comments	   Enables comment feature for the post	   true
//   tags	       Tags (Not available for pages)
//   categories	 Categories (Not available for pages)
//   permalink	   Overrides default permalink of post     Filename           MORE: http://hexo.io/docs/permalinks.html
//
// CATEGORIES & TAGS
// Categories and tags may sound familiar in other systems, but theyâre totally different in Hexo. Categories are hierarchical and ordered, which means Foo, Bar doesnât equal to Bar, Foo. Tags are unordered and flat.
//
// EXCERPTS
// You can hide parts of your post by adding <!-- more --> in the content. Index page will only show the post from the first to the second occurrence of <!-- more -->
//
// CODE SNIPPETS
// ``` [language] [title] [url] [link text]
// code snippet
// ```
//


// <div/iframe src="Fancybox.html"
//   data-param-original="/path/to/image"
//   data-param-thumbnail="/path/to/thumbnail"
//   data- param-title="title"
// >
//
// require('./Fancybox.js')("/path/to/image", "path/to/thumbnail", "title");
//
//
// {% fancybox /path/to/image [/path/to/thumbnail] [title] %}
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
(function FILE_FORMAT () {
  this.widget  = ['Blockquote', 'Profile'] // default widgets to use :-)
  // this means, that the stuff BELOW should fit the PARAMS specified
  // by the widgets above!
  this.name    = 'hans'
  this.author  = this.name + ' the man!'  // does not "live update" on change of "this.name"; // COMPUTED
  this.prog    = require('fs').toString() // does not "live update"
  this.bla     = require("./holonomy.js").name // copies, because "this.name" is atomic, so no "live update"
  this.content = function(markdown, html){/*
    ## Awsome
    here could be html or whatever, maybe markdown
    http://daringfireball.net/projects/markdown/basics
    ...
    and it can be multiline, because it uses
    https://www.npmjs.org/package/multiline
    ...
    and for markdown of course a markdown compiler
    ...
    and it needs a SYNTAX to reference stuff from above.
    it SHOULD NOT be able to use "require", because
    "require" should be used in the FRONT MATTER above.
    ...
    instead, it would use PLATES (or HOLON)
    ...
    how to use PLATES with MARKDOWN?
    MARKDOWN can use or include HTML,
    this is how, that means, for example:
    ...
    "Hello, my name is <span class="name"></span> :-)"
    ...
    it definitly needs an automatically inserted PREFIX,
    which should be based on the PATH, so that it converts into nice
    BEM STYLE, making it unique !!! :-)
    ... because this file is a JAVASCRIPT FILE, it might help to process it with
    => https://www.npmjs.org/package/falafel
    ...
    would i then be able to use:
    ...https://help.github.com/articles/3d-file-viewer/
        https://embed.githubusercontent.com/view/solid/skalnik/secret-bear-clip/master/stl/clip.stl?
        ???
  */}
  //// alternative:
  this.content = function () { return 'content.md'; } // or return 'content.md.html';
  // ==> this.content = require('holon')('content.md')(this)
}).call({/*module.exports*/});
